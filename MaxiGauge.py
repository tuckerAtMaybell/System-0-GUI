from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtCore import QTimer
# import the interface design generated by Qt designer
from . import MaxiGauge_Ui
import time
import csv

class Panel(QWidget):
    def __init__(self, parent=None, instr=None, lock=None, title='Instrument Panel'):
        # print('frig #2')
        # This class derivates from a Qt Widget so we have to call
        # the class builder ".__init__()"
        QWidget.__init__(self)
        # print('frig #2')
        # "self" is now a Qt Widget, then we load the user interface
        # generated with QtDesigner and call it self.ui
        self.ui = MaxiGauge_Ui.Ui_Panel()
        # print('frig #2')
        # Now we have to feed the GUI building method of this object (self.ui)
        # with the current Qt Widget 'self', but the widgets from the design will actually be built as children
        # of the object self.ui
        self.ui.setupUi(self) #ISSUE IS HERE
        self.setWindowTitle(title)
        self.reserved_access_to_instr = lock
        self.instr = instr
        # "frigg after instr"
        self.monitor_timer = QTimer()
        # print("frigg after monitor_timer")
#        # The timer would not wait for the completion of the task otherwise
        self.monitor_timer.setSingleShot(True)
        self.monitor_timer.timeout.connect(self.monitor)
        self.firsttime = 0
        # print("frigggggg")
        # bug: if the box is checked in the .ui file, the system freezes
        # if self.ui.monitor.isChecked():self.monitor()

    def monitor(self):
        state = self.ui.monitor.isChecked()
        if state != 1:
            # print("frig")
            self.monitor_timer.stop()
            #self.ui.close()
        elif state and not (self.monitor_timer.isActive()):
            self.firsttime += 1
            # print("FRIG")
            #self.ui.open()
            with self.reserved_access_to_instr:
                # print("FRIGG")
                self.ui.lcdNumber.display(float(self.instr.get_pressure(1)))
                self.ui.lcdNumber_2.display(float(self.instr.get_pressure(2)))
                self.ui.lcdNumber_3.display(float(self.instr.get_pressure(3)))
                self.ui.lcdNumber_4.display(float(self.instr.get_pressure(4)))
                self.ui.lcdNumber_5.display(float(self.instr.get_pressure(5)))
                self.ui.lcdNumber_6.display(float(self.instr.get_pressure(6)))
            self.monitor_timer.start(self.ui.refresh_rate.value() * 1000)

        with open('Pressure_log.csv', 'a', newline='') as file:
            writer = csv.writer(file)
            time_tick=time.strftime("%Y%m%d_%H%M%S")
            writer.writerow([time_tick, 1, self.instr.get_pressure(1)])
            writer.writerow([time_tick, 2, self.instr.get_pressure(2)])
            writer.writerow([time_tick, 3, self.instr.get_pressure(3)])
            writer.writerow([time_tick, 4, self.instr.get_pressure(4)])
            writer.writerow([time_tick, 5, self.instr.get_pressure(5)])
            writer.writerow([time_tick, 6, self.instr.get_pressure(6)])

    def update_timer_timeout(self, sec):
        # The value must be converted to milliseconds
        secs=float(sec.strip('secs'))
        self.monitor_timer.setInterval( secs * 1000)






if __name__ == "__main__":
    import sys

    app = QApplication(sys.argv)
    window = Panel(app)
    window.show()
    sys.exit(app.exec_())
